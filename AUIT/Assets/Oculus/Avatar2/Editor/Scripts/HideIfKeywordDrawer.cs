/*  Original code[1] Copyright (c) 2015 jistyles[2]
    Released as "public domain, no restrictions, no requirements, no support"
    Modified code[3] Copyright (c) 2018 Shane Celis[4]
    Licensed under the MIT License[5]

    This comment generated by code-cite[6].

    [1]: https://forum.unity.com/threads/sharing-is-caring-hiding-optional-material-parameters.349952/
    [2]: https://forum.unity.com/members/jistyles.458393/
    [3]: https://gitlab.com/snippets/1828392
    [4]: http://twitter.com/shanecelis
    [5]: https://opensource.org/licenses/MIT
    [6]: https://github.com/shanecelis/code-cite
*/
//$ cite -u https://forum.unity.com/threads/sharing-is-caring-hiding-optional-material-parameters.349952/ \
// -X jistyles -Y 2015 -Z https://forum.unity.com/members/jistyles.458393/ \
// -x shane -l mit -m -U https://gitlab.com/snippets/1828392

using UnityEngine;
using UnityEditor;

/**
   Hide or show properties in a material based on whether a given keyword is
   enabled or not.

   For instance, suppose we have a shader that has a toggle `RENDER_LINES` and
   there are properties that are irrelevant when it is disabled.

```
   [Toggle(RENDER_LINES)]
   _RenderLines ("Render Lines?", Float) = 0
   _LineDistance("Major Line Distance", Range(0, 2)) = 1
```

   We can add the following attribute to hide _LineDistance if RENDER_LINES is
   enabled. It reads, "hide if RENDER_LINES is false."

```
   [HideIfKeyword(RENDER_LINES, false)]
   _LineDistance("Major Line Distance", Range(0, 2)) = 1
```

   Or we can hide it if RENDER_LINES is disabled.  It reads, "hide if RENDER_LINES is true."

```
   [HideIfKeyword(RENDER_LINES, true)]
   _LineDistance("Major Line Distance", Range(0, 2)) = 1
```

   If no "true" or "false" argument is provided, it will default to true, so the
   following will hide if RENDER_LINES is enabled.  It reads, "hide if RENDER_LINES is true."

```
   [HideIfKeyword(RENDER_LINES)]
   _LineDistance("Major Line Distance", Range(0, 2)) = 1
```

  ShowIf
  ------

  The drawer `ShowIf` performs the same function but instead reads differently.

  [ShowIf(X, true)]

  ```
  [Toggle(RENDER_LINES)]
  _RenderLines ("Render Lines?", Float) = 0
  _LineDistance("Major Line Distance", Range(0, 2)) = 1
  ```

  We can add the following attribute to show _LineDistance if RENDER_LINES is
  enabled. It reads, "show if RENDER_LINES is false."

  ```
  [ShowIf(RENDER_LINES, false)]
  _LineDistance("Major Line Distance", Range(0, 2)) = 1
  ```

  Or we can show it if RENDER_LINES is disabled.  It reads, "show if RENDER_LINES is true."

  ```
  [ShowIf(RENDER_LINES, true)]
  _LineDistance("Major Line Distance", Range(0, 2)) = 1
  ```

  If no "true" or "false" argument is provided, it will default to true, so the
  following will show if RENDER_LINES is enabled.  It reads, "show if RENDER_LINES is true."

  ```
  [ShowIf(RENDER_LINES)]
  _LineDistance("Major Line Distance", Range(0, 2)) = 1
  ```

  Limitations
  -----------

  * Cannot work with other attributes, e.g., IntRange.

  See this [tweet thread](https://twitter.com/shanecelis/status/1098714764962877440) to see it in action.
*/
public class HideIfKeywordDrawer : MaterialPropertyDrawer {
  protected string[] _argValue;
  private bool[] _enabledQueries;

  //constructor permutations -- params doesn't seem to work for property drawer inputs :( -----------
  public HideIfKeywordDrawer(string name1) {
    _argValue = new[] {name1};
    _enabledQueries = new[] {true};
  }

  // Constructor for (name1 || name2) or (name1 is (name2 as bool))
  public HideIfKeywordDrawer(string name1, string name2) {
    if (bool.TryParse(name2, out bool e)) {
      _argValue = new[] {name1};
      _enabledQueries = new[] {e};
    } else {
      _argValue = new[] {name1, name2};
      _enabledQueries = new[] {true, true};
    }
  }

  // The booleans apply to every keyword before them.
  // Single boolean at name3 or
  // single boolean at name2
  public HideIfKeywordDrawer(string name1, string name2, string name3) {
    if (bool.TryParse(name3, out bool e)) {
      _argValue = new[] {name1, name2};
      _enabledQueries = new[] {e, e};
    } else if (bool.TryParse(name2, out e)) {
      _argValue = new[] {name1, name3};
      _enabledQueries = new[] {e, true};
    } else {
      _argValue = new[] {name1, name2, name3};
      _enabledQueries = new[] {true, true, true};
    }
  }

  // The booleans apply to every keyword before them.
  // Booleans can be at name2 and name4 or
  // single boolean at name4 or
  // single boolean at name3 or
  // single boolean at name2
  public HideIfKeywordDrawer(string name1, string name2, string name3, string name4) {
    if (bool.TryParse(name4, out bool e)) {
      // Can be either 2 or 3 component depending on if name2 is also a bool
      if (bool.TryParse(name2, out bool e2)) {
        _argValue = new[] {name1, name3};
        _enabledQueries = new[] {e2, e};
      } else {
        _argValue = new[] {name1, name2, name3};
        _enabledQueries = new[] {e, e, e};
      }
    } else if (bool.TryParse(name3, out e)) {
      _argValue = new[] {name1, name2, name4};
      _enabledQueries = new[] {e, e, true};
    } else if (bool.TryParse(name2, out e)) {
      _argValue = new[] {name1, name3, name4};
      _enabledQueries = new[] {e, true, true};
    } else {
      _argValue = new[] {name1, name2, name3, name4};
      _enabledQueries = new[] {true, true, true, true};
    }
  }

  //-------------------------------------------------------------------------------------------------

  public override void OnGUI(Rect position, MaterialProperty prop, string label, MaterialEditor editor) {
    bool elementMatches = KeywordsOr(editor.targets);

    if (ShowElement(elementMatches))
      editor.DefaultShaderProperty(prop, label);
  }

  public bool KeywordsOr(Object[] targets) {
    bool elementMatches = false;
    for (int i = 0; i < targets.Length; i++) {
      //material object that we're targetting...
      Material mat = targets[i] as Material;
      if (mat != null) {
        //check for the dependencies:
        for (int j = 0; j < _argValue.Length; j++) {
          elementMatches |= mat.IsKeywordEnabled(_argValue[j]) == _enabledQueries[j];
        }
      }
    }

    return elementMatches;
  }

  protected virtual bool ShowElement(bool matched) => !matched;

  //We need to override the height so it's not adding any extra (unfortunately
  //texture drawers will still add an extra bit of padding regardless):
  public override float GetPropertyHeight(MaterialProperty prop, string label, MaterialEditor editor) {
    return -EditorGUIUtility.standardVerticalSpacing;
  }
}


public class ShowIfKeywordDrawer : HideIfKeywordDrawer {

  public ShowIfKeywordDrawer(string name1) : base(name1) {
  }
  public ShowIfKeywordDrawer(string name1, string name2) : base(name1, name2) {
  }
  public ShowIfKeywordDrawer(string name1, string name2, string name3) : base(name1, name2, name3) {
  }

  public ShowIfKeywordDrawer(string name1, string name2, string name3, string name4) :
    base(name1, name2, name3, name4)
  {

  }

  protected override bool ShowElement(bool matched) => matched;
}

// Booleans required for both sides of the "and".
public class HideIfKeywordAndDrawer : MaterialPropertyDrawer {

  private HideIfKeywordDrawer leftSide_;
  private HideIfKeywordDrawer rightSide_;

  public HideIfKeywordAndDrawer(string name1, string name2, string name3, string name4, string name5)
  {
    // Find boolean locations
    // Will either be (A, B, [bool], C, [bool])
    // or (A, [bool], B, C, [bool])
    if (bool.TryParse(name3, out bool e)) {
      // (A, B, [bool], C, [bool])
      leftSide_ = new HideIfKeywordDrawer(name1, name2, name3);
      rightSide_ = new HideIfKeywordDrawer(name4, name5);
    } else {
      // (A, [bool], B, C, [bool])
      leftSide_ = new HideIfKeywordDrawer(name1, name2);
      rightSide_ = new HideIfKeywordDrawer(name3, name4, name5);
    }
  }


  public override void OnGUI(Rect position, MaterialProperty prop, string label, MaterialEditor editor) {
    bool elementMatches = leftSide_.KeywordsOr(editor.targets);
    elementMatches &= rightSide_.KeywordsOr(editor.targets);

    if (ShowElement(elementMatches))
      editor.DefaultShaderProperty(prop, label);
  }

  protected virtual bool ShowElement(bool matched) => !matched;

  //We need to override the height so it's not adding any extra (unfortunately
  //texture drawers will still add an extra bit of padding regardless):
  public override float GetPropertyHeight(MaterialProperty prop, string label, MaterialEditor editor) {
    return -EditorGUIUtility.standardVerticalSpacing;
  }
}

public class ShowIfKeywordAndDrawer : HideIfKeywordAndDrawer {
  public ShowIfKeywordAndDrawer(string name1, string name2, string name3, string name4, string name5) :
    base(name1, name2, name3, name4, name5)
  {

  }

  protected override bool ShowElement(bool matched) => matched;
}
